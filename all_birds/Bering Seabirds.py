# -*- coding: utf-8 -*-
# <nbformat>3.0</nbformat>

# <markdowncell>

# ### Load Important Bird Areas

# <codecell>

from owslib.wfs import WebFeatureService
known_wfs = "http://solo.axiomalaska.com/geoserver/audubon/ows"
wfs = WebFeatureService(known_wfs, version='1.0.0')
geojson_response = wfs.getfeature(typename=['audubon:audubon_ibas'], outputFormat="application/json", srsname="urn:x-ogc:def:crs:EPSG:4326").read()

# <codecell>

import json
from utilities import find_dict_keys

from shapely.geometry import shape, MultiPolygon

geojson = json.loads(geojson_response)    
geometries = find_dict_keys("geometry", geojson)
shapes = [shape(g) for g in geometries]

# <codecell>

import folium
from utilities import get_coords

map_center = shapes[0].centroid
mapper = folium.Map(location=[map_center.x, map_center.y], zoom_start=3)
for s in shapes:
    for c in get_coords(s):
        mapper.line(c, line_color='#FF0000', line_weight=5)
mapper._build_map()

from IPython.core.display import HTML
HTML('<iframe srcdoc="{srcdoc}" style="width: 100%; height: 535px; border: none"></iframe>'.format(srcdoc=mapper.HTML.replace('"', '&quot;')))

# <markdowncell>

# ### Set time filter

# <codecell>

min_time = "2013-01-01"  # UTC
max_time = "2013-02-01"  # UTC

import pytz
from dateutil.parser import parse
min_time = parse(min_time).replace(tzinfo=pytz.utc)
max_time = parse(max_time).replace(tzinfo=pytz.utc)

# <markdowncell>

# ### Set bbox filter

# <codecell>

# miny, minx, maxy, maxx
minx = -163
miny = 63
maxx = -161
maxy = 65
analysis_box = miny, minx, maxy, maxx

from shapely.geometry import box
bound = box(*analysis_box).boundary.coords
mapper.line(bound, line_color='#0000FF', line_weight=5)
mapper._build_map()

# <codecell>

from IPython.core.display import HTML
HTML('<iframe srcdoc="{srcdoc}" style="width: 100%; height: 535px; border: none"></iframe>'.format(srcdoc=mapper.HTML.replace('"', '&quot;')))

# <markdowncell>

# ### Load model data

# <codecell>

# Global sea surface temperature
model = 'http://thredds.axiomalaska.com/thredds/dodsC/G1_SST.nc'
standard_name = 'sea_surface_temperature'

# <codecell>

import netCDF4
nc = netCDF4.Dataset(model)

# <markdowncell>

# #### Pull in the variable we want to analyze

# <codecell>

from utilities import get_variable_from_standard
variable = get_variable_from_standard(nc, standard_name)[0]

# <codecell>

variable.shape

# <codecell>

variable.dimensions

# <markdowncell>

# #### Subset by bounding box

# <codecell>

import numpy as np

lat_var = get_variable_from_standard(nc, "latitude")[0]
lat_indexes = np.logical_and(lat_var[:] <= maxy,
                             lat_var[:] >= miny)
lat_indexes = np.where(lat_indexes)
lat_data = lat_var[lat_indexes]


lon_var = get_variable_from_standard(nc, "longitude")[0]
lon_indexes = np.logical_and(lon_var[:] <= maxx,
                             lon_var[:] >= minx)
lon_indexes = np.where(lon_indexes)
lon_data = lon_var[lon_indexes]

# <markdowncell>

# #### Subset by time

# <codecell>

import calendar
from datetime import datetime

time_var = get_variable_from_standard(nc, "time")[0]

if time_var.dtype == np.dtype('S1'):
    def str_to_epoch(date_str):
        return calendar.timegm(parse(date_str).replace(tzinfo=pytz.utc).timetuple())
    new_time = netCDF4.chartostring(time_var[:])
    time_var.units = "seconds since 1970-01-01"
    new_min_time = calendar.timegm(min_time.timetuple())
    new_max_time = calendar.timegm(max_time.timetuple())
    np_str_to_epoch = np.vectorize(str_to_epoch)
    new_time = np_str_to_epoch(new_time)
    time_indexes = np.logical_and(new_time[:] <= new_max_time,
                                  new_time[:] >= new_min_time)
    time_indexes = np.where(time_indexes)
    time_data = new_time[time_indexes]
    time_data = netCDF4.num2date(time_data, time_var.units)
else:
    new_min_time, new_max_time = netCDF4.date2num([min_time, max_time], time_var.units)
    time_indexes = np.logical_and(time_var[:] <= new_max_time,
                                  time_var[:] >= new_min_time)
    time_indexes = np.where(time_indexes)
    time_data = time_var[time_indexes]
    time_data = netCDF4.num2date(time_data, time_var.units)

# <markdowncell>

# #### Subset variable

# <codecell>

subset_variable = variable[time_indexes[0], lat_indexes[0], lon_indexes[0]]

# <codecell>

import pandas as pd
data = pd.Panel(subset_variable, items=time_data, major_axis=lat_data, minor_axis=lon_data)

# <codecell>

data

# <codecell>

data.to_frame().head(20)

# <codecell>


