# -*- coding: utf-8 -*-
# <nbformat>3.0</nbformat>

# <markdowncell>

# # Subset higher order stats by our bounding boxes

# <codecell>

#A list of imports we need for code later in the notebook.
#The css_styles() function must go last.
%matplotlib inline
from owslib.wfs import WebFeatureService
import json
from utilities import find_dict_keys
from shapely.geometry import shape, MultiPolygon
from shapely.geometry import box

import folium
from utilities import get_coords
from IPython.core.display import HTML

import time
import numpy as np
from numpy import ma
import netCDF4
import pandas as pd
from pandas import Series

import matplotlib as mpl
from matplotlib import cm
import matplotlib.pyplot as plt
from matplotlib import ticker

from utilities import css_styles
css_styles()

# <codecell>

#Load our important bird areas again.
known_wfs = "http://solo.axiomalaska.com/geoserver/audubon/ows"
wfs = WebFeatureService(known_wfs, version='1.0.0')
geojson_response = wfs.getfeature(typename=['audubon:audubon_ibas'], outputFormat="application/json", srsname="urn:x-ogc:def:crs:EPSG:4326").read()
geojson = json.loads(geojson_response)

geometries = find_dict_keys('geometry', geojson)
shapes = [shape(g) for g in geometries]

sitenums = find_dict_keys('sitenum', geojson)
sitenums = [str(s) for s in sitenums]

objectids = find_dict_keys('objectid', geojson)
objectids = [str(s) for s in objectids]

#This generates bounding boxes from the complex geometries in shapes.
miny = list()
minx = list()
maxy = list()
maxx = list()
for s in shapes:
    miny.append(s.bounds[0])
    minx.append(s.bounds[1])
    maxy.append(s.bounds[2])
    maxx.append(s.bounds[3])
# miny, minx, maxy, maxx

# <codecell>

#Bring in netCDF datasets
#Set datasets
avg = netCDF4.Dataset('/augie/gluster/data/netCDF/pmel/core/Outputs/core_average.nc')
stddev = netCDF4.Dataset('/augie/gluster/data/netCDF/pmel/core/Outputs/core_rmssdn.nc')
pavg = netCDF4.Dataset('/augie/gluster/data/netCDF/pmel/cccma/Outputs/cccma_average.nc')
pstddev = netCDF4.Dataset('/augie/gluster/data/netCDF/pmel/cccma/Outputs/cccma_rmssdn.nc')

# <codecell>

# Load latitude and longitude arrays
latitude = np.array(avg.variables['LATITUDE'])
longitude = np.array(avg.variables['LONGITUDE'])

# <markdowncell>

# Some shapes will be empty (i.e., there's a polygon, but no model data), others will have very few values. We should keep track of how many model pixels are going into each resulting mean. For the combined IBAs, there are 210 polygons, identified by sitenums, objectids, and their geometries.

# <markdowncell>

# ##Store the results by keeping track of the data in a Pandas Dataframe
# We will append columns to these and fill in the data as we get it.

# <codecell>

outputs = pd.DataFrame({'sitenum': sitenums,
                        'objectid': objectids,
                        'miny': miny,
                        'minx': minx,
                        'maxy': maxy,
                        'maxx': maxx
                        },
                       columns = ['sitenum', 'objectid', 'miny', 'minx', 'maxy', 'maxx'])

# <codecell>

print outputs.head()

# <codecell>

print outputs.ix[2,2]

# <codecell>

#Each indexed shape has a bounds, with miny, minx, maxy, maxx in lat/lon
#we're going to convert these to pixel values.
shape = shapes[4].bounds
miny = shape[0]
minx = shape[1]
maxy = shape[2]
maxx = shape[3]

lat_indices = np.logical_and(latitude <= maxy, latitude >= miny)
lat_indices = np.where(lat_indices)
lat_data = latitude[lat_indices]

#PMEL models are in positive east, so we have to convert our bounding box.
minx_modulo360 = minx + 360.
maxx_modulo360 = maxx + 360.

lon_indices = np.logical_and(longitude[:] <= maxx_modulo360, longitude[:] >= minx_modulo360)

lon_indices = np.where(lon_indices)
lon_data = longitude[lon_indices]

# <codecell>

print lon_indices

# <codecell>

import pandas as pd
data = pd.Panel(subset_variable, items=time_data, major_axis=lat_data, minor_axis=lon_data)

